package com.randonautica.app.Attractors;

import android.app.Activity;
import android.app.AlertDialog;
import android.app.ProgressDialog;
import android.content.Context;
import android.content.DialogInterface;
import android.graphics.Color;
import android.util.Base64;
import android.view.View;

import com.mapbox.mapboxsdk.annotations.MarkerOptions;
import com.mapbox.mapboxsdk.annotations.PolygonOptions;
import com.mapbox.mapboxsdk.geometry.LatLng;
import com.mapbox.mapboxsdk.maps.MapboxMap;
import com.randonautica.app.Classes.AttractorLocation;
import com.randonautica.app.Classes.DatabaseHelper;
import com.randonautica.app.Classes.PseudoAttractorLocation;
import com.randonautica.app.Classes.SingleRecyclerViewLocation;
import com.randonautica.app.Interfaces.API_Classes.GoAttractors;
import com.randonautica.app.Interfaces.API_Classes.Point;
import com.randonautica.app.Interfaces.API_Classes.PseudoAttractor;
import com.randonautica.app.Interfaces.API_Classes.Sizes;
import com.randonautica.app.Interfaces.RandoWrapperApi;
import com.randonautica.app.Interfaces.RandonautAttractorListener;
import com.randonautica.app.MyRandonautFragment;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.ThreadLocalRandom;
import java.util.concurrent.TimeUnit;

import okhttp3.OkHttpClient;
import retrofit2.Call;
import retrofit2.Callback;
import retrofit2.Response;
import retrofit2.Retrofit;
import retrofit2.converter.gson.GsonConverterFactory;

import static java.lang.Math.atan2;
import static java.lang.Math.cos;
import static java.lang.Math.sin;
import static java.lang.Math.sqrt;

public class GenerateAttractors extends Activity {

    //Pseudo range
    private int N;

    //Contains locations generated by attractor functions
    public static ArrayList<SingleRecyclerViewLocation> locationList = new ArrayList<>();

    //initialize Classes
    DatabaseHelper mDatabaseHelper;
    RandoWrapperApi randoWrapperApi;
    ProgressDialog progressdialog;

    //Database tables to store attractors
    String attractorTable = "Attractors";
    String voidTable = "Voids";
    String anomalyTable = "Anomalies";

    public void getAttractors(final View view, final MapboxMap mapboxMap, final Context context,
                              String GID, boolean pool, boolean temporal, boolean gcp, final String selected, final int distance, final RandonautAttractorListener randonautDialogsListener){
        //Empty previous run
        locationList = new ArrayList<>();
        mapboxMap.clear();

        //Start ProgressDialog
        progressdialog = new ProgressDialog(context);
        progressdialog.setMessage("Looking for " + selected + "s " + "please wait....");
        progressdialog.show();
        progressdialog.setCancelable(false);
        progressdialog.setCanceledOnTouchOutside(false);

        OkHttpClient okHttpClient = new OkHttpClient().newBuilder()
                .connectTimeout(175, TimeUnit.SECONDS)
                .readTimeout(175, TimeUnit.SECONDS)
                .writeTimeout(175, TimeUnit.SECONDS)
                .build();

        Retrofit retrofit = new Retrofit.Builder()
                .baseUrl(new String(Base64.decode(MyRandonautFragment.getBaseApi(),Base64.DEFAULT)))
                .client(okHttpClient)
                .addConverterFactory(GsonConverterFactory.create())
                .build();

        randoWrapperApi = retrofit.create(RandoWrapperApi.class);

        Call<GoAttractors> callGetAttractors = randoWrapperApi.getAttractors(GID,
                mapboxMap.getLocationComponent().getLastKnownLocation().getLatitude(), mapboxMap.getLocationComponent().getLastKnownLocation().getLongitude(), distance, pool, temporal, gcp);

        callGetAttractors.enqueue(new Callback<GoAttractors>() {
            @Override
            public void onResponse(Call<GoAttractors> call, Response<GoAttractors> response) {

                int i = 0;
                int count = 0;
                int amount = 0;
                for(Point attractors: response.body().getPoints()){
                    count ++;
                }

                AttractorLocation attractorLocations[] =new AttractorLocation[count];

                for(int attractorcount = 0; attractorcount < count; attractorcount++){

                    //First Part
                    double GID = response.body().getPoints().get(attractorcount).getGID();
                    double TID = response.body().getPoints().get(attractorcount).getTID();
                    double LID = response.body().getPoints().get(attractorcount).getLID();
                    double type = response.body().getPoints().get(attractorcount).getType();
                    double x_ = response.body().getPoints().get(attractorcount).getX();
                    double y_ = response.body().getPoints().get(attractorcount).getY();


                    //Second part
                    double x = response.body().getPoints().get(attractorcount).getCenter().getPoint().getLatitude(); //Used in map
                    double y = response.body().getPoints().get(attractorcount).getCenter().getPoint().getLongitude(); //Used in map

                    double distance = response.body().getPoints().get(attractorcount).getCenter().getBearing().getDistance();
                    double initialBearing = response.body().getPoints().get(attractorcount).getCenter().getBearing().getInitialBearing();
                    double finalBearing = response.body().getPoints().get(attractorcount).getCenter().getBearing().getFinalBearing();

                    //Third part
                    double side = response.body().getPoints().get(attractorcount).getSide();
                    double distanceErr = response.body().getPoints().get(attractorcount).getDistanceErr();
                    double radiusM = response.body().getPoints().get(attractorcount).getRadiusM();
                    double n = response.body().getPoints().get(attractorcount).getN();
                    double mean = response.body().getPoints().get(attractorcount).getMean();
                    double rarity = response.body().getPoints().get(attractorcount).getRarity();
                    double power_old = response.body().getPoints().get(attractorcount).getPowerOld();
                    double power = response.body().getPoints().get(attractorcount).getPower();
                    double z_score = response.body().getPoints().get(attractorcount).getZScore();
                    double probability_single = response.body().getPoints().get(attractorcount).getProbabilitySingle();
                    double integral_score = response.body().getPoints().get(attractorcount).getIntegralScore();
                    double significance = response.body().getPoints().get(attractorcount).getSignificance();
                    double probability = response.body().getPoints().get(attractorcount).getProbability();

                    //#TODO: FIX FILTERING SIGNIFICANCE IN GOWRAPPER
                    int FILTERING_SIGNIFICANCE = 4;

                    attractorLocations[i]=new AttractorLocation(new LatLng(x, y), GID,  TID,  LID,  x_,  y_,  distance,  initialBearing,  finalBearing, side,  distanceErr,  radiusM, n,  mean, rarity,  power_old,  probability_single,  integral_score,  significance,  probability, FILTERING_SIGNIFICANCE, type, radiusM,  power,  z_score);

                    if(selected == "Attractor" && type == 1){
                        //Make databaseHelper
                        mDatabaseHelper = new DatabaseHelper(context, attractorTable);

                        //Generate Marker
                        mapboxMap.addMarker(new MarkerOptions()
                                .position(new LatLng(x, y))
                                .title("Attractor"));

                        //Generate Circle
                        mapboxMap.addPolygon(generatePerimeter(
                                new LatLng(x, y),
                                (radiusM/1000),
                                64));

                        amount++;
                        MyRandonautFragment.atts++;
                        SingleRecyclerViewLocation singleLocation = new SingleRecyclerViewLocation();
                        singleLocation.setType((attractorLocations[i].getType()));
                        singleLocation.setRadiusm((attractorLocations[i].getRadiusM()));
                        singleLocation.setPower((attractorLocations[i].getPower()));
                        singleLocation.setZ_score((attractorLocations[i].getZ_score()));
                        singleLocation.setLocationCoordinates(attractorLocations[i].getCoordinate());
                        singleLocation.setPsuedo(false);
                        //getRoutesToAllPoints(attractorLocations[i].getCoordinate());

                        AddData(attractorTable,
                                attractorLocations[i].getCoordinate().getLatitude(),
                                attractorLocations[i].getCoordinate().getLongitude(),
                                attractorLocations[i].getGID(),
                                attractorLocations[i].getTID(),
                                attractorLocations[i].getLID(),

                                attractorLocations[i].getX(),
                                attractorLocations[i].getY(),
                                attractorLocations[i].getDistance(),
                                attractorLocations[i].getInitialBearing(),
                                attractorLocations[i].getFinalBearing(),
                                attractorLocations[i].getSide(),
                                attractorLocations[i].getDistanceErr(),
                                attractorLocations[i].getRadiusM(),
                                attractorLocations[i].getN(),
                                attractorLocations[i].getMean(),
                                attractorLocations[i].getRarity(),
                                attractorLocations[i].getPower_old(),
                                attractorLocations[i].getProbability_single(),
                                attractorLocations[i].getIntegral_score(),
                                attractorLocations[i].getSignificance(),
                                attractorLocations[i].getProbability(),
                                attractorLocations[i].getFILTERING_SIGNIFICANCE(),
                                attractorLocations[i].getType(),
                                attractorLocations[i].getRadiusM(),
                                attractorLocations[i].getPower(),
                                attractorLocations[i].getZ_score(),
                                0, 0);

                        locationList.add(singleLocation);

                    }

                    if(selected == "Void" && type == 2){
                        mDatabaseHelper = new DatabaseHelper(context, voidTable);

                        //Generate Marker
                        mapboxMap.addMarker(new MarkerOptions()
                                .position(new LatLng(x, y))
                                .title("Void"));

                        //Generate Circle
                        mapboxMap.addPolygon(generatePerimeter(
                                new LatLng(x, y),
                                (attractorLocations[i].getRadiusM()/1000),
                                64));

                        amount++;
                        MyRandonautFragment.voids++;
                        SingleRecyclerViewLocation singleLocation = new SingleRecyclerViewLocation();
                        singleLocation.setType((attractorLocations[i].getType()));
                        singleLocation.setRadiusm((attractorLocations[i].getRadiusM()));
                        singleLocation.setPower((attractorLocations[i].getPower()));
                        singleLocation.setZ_score((attractorLocations[i].getZ_score()));
                        singleLocation.setLocationCoordinates(attractorLocations[i].getCoordinate());
                        singleLocation.setPsuedo(false);

                        AddData(voidTable,
                                attractorLocations[i].getCoordinate().getLatitude(),
                                attractorLocations[i].getCoordinate().getLongitude(),
                                attractorLocations[i].getGID(),
                                attractorLocations[i].getTID(),
                                attractorLocations[i].getLID(),

                                attractorLocations[i].getX(),
                                attractorLocations[i].getY(),
                                attractorLocations[i].getDistance(),
                                attractorLocations[i].getInitialBearing(),
                                attractorLocations[i].getFinalBearing(),
                                attractorLocations[i].getSide(),
                                attractorLocations[i].getDistanceErr(),
                                attractorLocations[i].getRadiusM(),
                                attractorLocations[i].getN(),
                                attractorLocations[i].getMean(),
                                attractorLocations[i].getRarity(),
                                attractorLocations[i].getPower_old(),
                                attractorLocations[i].getProbability_single(),
                                attractorLocations[i].getIntegral_score(),
                                attractorLocations[i].getSignificance(),
                                attractorLocations[i].getProbability(),
                                attractorLocations[i].getFILTERING_SIGNIFICANCE(),
                                attractorLocations[i].getType(),
                                attractorLocations[i].getRadiusM(),
                                attractorLocations[i].getPower(),
                                attractorLocations[i].getZ_score(),
                                0, 0);

                        locationList.add(singleLocation);

                    }

                    i++;
                }

                //Check for anomaly
                if(selected == "Anomalie"){
                    for (int c = count - 1; c > 0; c--) { //Start bubblesort
                        for (int j = 0; j < c; j++) {
                            if (attractorLocations[j + 1] == null) {
                                continue;
                            }
                            if (attractorLocations[j] == null || attractorLocations[j + 1].compareTo(attractorLocations[j]) < 0) {
                                AttractorLocation temp = attractorLocations[j + 1];
                                attractorLocations[j + 1] = attractorLocations[j];
                                attractorLocations[j] = temp;
                            }
                        }
                    } //End bubblesort
                    for(i = 0; i < count; i++){

                        //Make databaseHelper
                        mDatabaseHelper = new DatabaseHelper(context, anomalyTable);

                        //Generate Marker
                        mapboxMap.addMarker(new MarkerOptions()
                                .position(new LatLng(attractorLocations[i].getCoordinate().getLatitude(),  attractorLocations[i].getCoordinate().getLongitude()))
                                .title("Attractor"));

                        //Generate Circle
                        mapboxMap.addPolygon(generatePerimeter(
                                new LatLng( attractorLocations[i].getCoordinate().getLatitude(),  attractorLocations[i].getCoordinate().getLongitude()),
                                (attractorLocations[i].getRadiusM()/1000),
                                64));

                        amount++;
                        MyRandonautFragment.anomalies++;
                        SingleRecyclerViewLocation singleLocation = new SingleRecyclerViewLocation();
                        singleLocation.setType((attractorLocations[i].getType()));
                        singleLocation.setRadiusm((attractorLocations[i].getRadiusM()));
                        singleLocation.setPower((attractorLocations[i].getPower()));
                        singleLocation.setZ_score((attractorLocations[i].getZ_score()));
                        singleLocation.setLocationCoordinates(attractorLocations[i].getCoordinate());
                        singleLocation.setPsuedo(false);

                        AddData(anomalyTable,
                                attractorLocations[i].getCoordinate().getLatitude(),
                                attractorLocations[i].getCoordinate().getLongitude(),
                                attractorLocations[i].getGID(),
                                attractorLocations[i].getTID(),
                                attractorLocations[i].getLID(),

                                attractorLocations[i].getX(),
                                attractorLocations[i].getY(),
                                attractorLocations[i].getDistance(),
                                attractorLocations[i].getInitialBearing(),
                                attractorLocations[i].getFinalBearing(),
                                attractorLocations[i].getSide(),
                                attractorLocations[i].getDistanceErr(),
                                attractorLocations[i].getRadiusM(),
                                attractorLocations[i].getN(),
                                attractorLocations[i].getMean(),
                                attractorLocations[i].getRarity(),
                                attractorLocations[i].getPower_old(),
                                attractorLocations[i].getProbability_single(),
                                attractorLocations[i].getIntegral_score(),
                                attractorLocations[i].getSignificance(),
                                attractorLocations[i].getProbability(),
                                attractorLocations[i].getFILTERING_SIGNIFICANCE(),
                                attractorLocations[i].getType(),
                                attractorLocations[i].getRadiusM(),
                                attractorLocations[i].getPower(),
                                attractorLocations[i].getZ_score(),
                                0, 0);

                        locationList.add(singleLocation);

                        i ++;
                    }



                } //End anomaly

                if(amount > 0){
                    randonautDialogsListener.onData(locationList);
                    MyRandonautFragment.startButton.setVisibility(View.GONE);
                    // navigateButton.setVisibility(View.VISIBLE);
                    MyRandonautFragment.resetButton.setVisibility(View.VISIBLE);
                } else {
                    //Nothhing was found
                    createDialogEmptyResults(context, selected, mapboxMap.getLocationComponent().getLastKnownLocation().getLatitude(), mapboxMap.getLocationComponent().getLastKnownLocation().getLongitude(), distance, randonautDialogsListener, mapboxMap);
                }

                //saveData();
                progressdialog.dismiss();
            }

            @Override
            public void onFailure(Call<GoAttractors> call, Throwable t) {
                progressdialog.dismiss();
                createDialogEmptyResults(context, selected, mapboxMap.getLocationComponent().getLastKnownLocation().getLatitude(), mapboxMap.getLocationComponent().getLastKnownLocation().getLongitude(), distance, randonautDialogsListener, mapboxMap);
            }


        });
    }

    public void getAttractorsFromSetEntropy(final View view, final MapboxMap mapboxMap, final Context context,
                                            String GID, boolean pool, boolean temporal, boolean gcp, final String selected, final int distance, final RandonautAttractorListener randonautDialogsListener){
        //Empty previous run
        locationList = new ArrayList<>();
        mapboxMap.clear();
        //removeRecyclerView(view);

        //Start ProgressDialog
        progressdialog = new ProgressDialog(context);
        progressdialog.setMessage("Looking for " + selected + "s " + "please wait....");
        progressdialog.show();
        progressdialog.setCancelable(false);
        progressdialog.setCanceledOnTouchOutside(false);

        OkHttpClient okHttpClient = new OkHttpClient().newBuilder()
                .connectTimeout(175, TimeUnit.SECONDS)
                .readTimeout(175, TimeUnit.SECONDS)
                .writeTimeout(175, TimeUnit.SECONDS)
                .build();

        Retrofit retrofit = new Retrofit.Builder()
                .baseUrl(new String(Base64.decode(MyRandonautFragment.getBaseApi(),Base64.DEFAULT)))
                .client(okHttpClient)
                .addConverterFactory(GsonConverterFactory.create())
                .build();

        randoWrapperApi = retrofit.create(RandoWrapperApi.class);

        Call<GoAttractors> callGetAttractors = randoWrapperApi.getAttractors(GID,
                mapboxMap.getLocationComponent().getLastKnownLocation().getLatitude(), mapboxMap.getLocationComponent().getLastKnownLocation().getLongitude(), distance, pool, temporal, gcp);

        callGetAttractors.enqueue(new Callback<GoAttractors>() {
            @Override
            public void onResponse(Call<GoAttractors> call, Response<GoAttractors> response) {

                int i = 0;
                int count = 0;
                int amount = 0;

                for(Point attractors: response.body().getPoints()){
                    count ++;
                }

                AttractorLocation attractorLocations[] =new AttractorLocation[count];

                for(Point attractors: response.body().getPoints()){

                    //First Part
                    double GID = attractors.getGID();
                    double TID = attractors.getTID();
                    double LID = attractors.getLID();
                    double type = attractors.getType();
                    double x_ = attractors.getX();
                    double y_ = attractors.getY();


                    //Second part
                    double x = attractors.getCenter().getPoint().getLatitude(); //Used in map
                    double y = attractors.getCenter().getPoint().getLongitude(); //Used in map

                    double distance = attractors.getCenter().getBearing().getDistance();
                    double initialBearing = attractors.getCenter().getBearing().getInitialBearing();
                    double finalBearing = attractors.getCenter().getBearing().getFinalBearing();

                    //Third part
                    double side = attractors.getSide();
                    double distanceErr = attractors.getDistanceErr();
                    double radiusM = attractors.getRadiusM();
                    double n = attractors.getN();
                    double mean = attractors.getMean();
                    double rarity = attractors.getRarity();
                    double power_old = attractors.getPowerOld();
                    double power = attractors.getPower();
                    double z_score = attractors.getZScore();
                    double probability_single = attractors.getProbabilitySingle();
                    double integral_score = attractors.getIntegralScore();
                    double significance = attractors.getSignificance();
                    double probability = attractors.getProbability();
                    int FILTERING_SIGNIFICANCE = 4;
                    attractorLocations[i]=new AttractorLocation(new LatLng(x, y), GID,  TID,  LID,  x_,  y_,  distance,  initialBearing,  finalBearing, side,  distanceErr,  radiusM, n,  mean, rarity,  power_old,  probability_single,  integral_score,  significance,  probability, FILTERING_SIGNIFICANCE, type, radiusM,  power,  z_score);

                    if(type == 1){
                        //Make databaseHelper
                        mDatabaseHelper = new DatabaseHelper(context, attractorTable);

                        //Generate Marker
                        mapboxMap.addMarker(new MarkerOptions()
                                .position(new LatLng(x, y))
                                .title("Attractor"));

                        //Generate Circle
                        mapboxMap.addPolygon(generatePerimeter(
                                new LatLng(x, y),
                                (radiusM/1000),
                                64));

                        amount++;
                        MyRandonautFragment.atts++;
                        SingleRecyclerViewLocation singleLocation = new SingleRecyclerViewLocation();
                        singleLocation.setType((attractorLocations[i].getType()));
                        singleLocation.setRadiusm((attractorLocations[i].getRadiusM()));
                        singleLocation.setPower((attractorLocations[i].getPower()));
                        singleLocation.setZ_score((attractorLocations[i].getZ_score()));
                        singleLocation.setLocationCoordinates(attractorLocations[i].getCoordinate());
                        singleLocation.setPsuedo(false);

                        AddData(attractorTable,
                                attractorLocations[i].getCoordinate().getLatitude(),
                                attractorLocations[i].getCoordinate().getLongitude(),
                                attractorLocations[i].getGID(),
                                attractorLocations[i].getTID(),
                                attractorLocations[i].getLID(),

                                attractorLocations[i].getX(),
                                attractorLocations[i].getY(),
                                attractorLocations[i].getDistance(),
                                attractorLocations[i].getInitialBearing(),
                                attractorLocations[i].getFinalBearing(),
                                attractorLocations[i].getSide(),
                                attractorLocations[i].getDistanceErr(),
                                attractorLocations[i].getRadiusM(),
                                attractorLocations[i].getN(),
                                attractorLocations[i].getMean(),
                                attractorLocations[i].getRarity(),
                                attractorLocations[i].getPower_old(),
                                attractorLocations[i].getProbability_single(),
                                attractorLocations[i].getIntegral_score(),
                                attractorLocations[i].getSignificance(),
                                attractorLocations[i].getProbability(),
                                attractorLocations[i].getFILTERING_SIGNIFICANCE(),
                                attractorLocations[i].getType(),
                                attractorLocations[i].getRadiusM(),
                                attractorLocations[i].getPower(),
                                attractorLocations[i].getZ_score(),
                                0, 0);

                        locationList.add(singleLocation);

                    }

                    if(type == 2){
                        mDatabaseHelper = new DatabaseHelper(context, voidTable);

                        //Generate Marker
                        mapboxMap.addMarker(new MarkerOptions()
                                .position(new LatLng(x, y))
                                .title("Void"));

                        //Generate Circle
                        mapboxMap.addPolygon(generatePerimeter(
                                new LatLng(x, y),
                                (attractorLocations[i].getRadiusM()/1000),
                                64));

                        amount++;
                        MyRandonautFragment.voids++;
                        SingleRecyclerViewLocation singleLocation = new SingleRecyclerViewLocation();
                        singleLocation.setType((attractorLocations[i].getType()));
                        singleLocation.setRadiusm((attractorLocations[i].getRadiusM()));
                        singleLocation.setPower((attractorLocations[i].getPower()));
                        singleLocation.setZ_score((attractorLocations[i].getZ_score()));
                        singleLocation.setLocationCoordinates(attractorLocations[i].getCoordinate());
                        singleLocation.setPsuedo(false);

                        AddData(voidTable,
                                attractorLocations[i].getCoordinate().getLatitude(),
                                attractorLocations[i].getCoordinate().getLongitude(),
                                attractorLocations[i].getGID(),
                                attractorLocations[i].getTID(),
                                attractorLocations[i].getLID(),

                                attractorLocations[i].getX(),
                                attractorLocations[i].getY(),
                                attractorLocations[i].getDistance(),
                                attractorLocations[i].getInitialBearing(),
                                attractorLocations[i].getFinalBearing(),
                                attractorLocations[i].getSide(),
                                attractorLocations[i].getDistanceErr(),
                                attractorLocations[i].getRadiusM(),
                                attractorLocations[i].getN(),
                                attractorLocations[i].getMean(),
                                attractorLocations[i].getRarity(),
                                attractorLocations[i].getPower_old(),
                                attractorLocations[i].getProbability_single(),
                                attractorLocations[i].getIntegral_score(),
                                attractorLocations[i].getSignificance(),
                                attractorLocations[i].getProbability(),
                                attractorLocations[i].getFILTERING_SIGNIFICANCE(),
                                attractorLocations[i].getType(),
                                attractorLocations[i].getRadiusM(),
                                attractorLocations[i].getPower(),
                                attractorLocations[i].getZ_score(),
                                0, 0);

                        locationList.add(singleLocation);

                    }

                    i++;
                }

                if(amount > 0){
                    randonautDialogsListener.onData(locationList);
                    MyRandonautFragment.startButton.setVisibility(View.GONE);
                    // navigateButton.setVisibility(View.VISIBLE);
                    MyRandonautFragment.resetButton.setVisibility(View.VISIBLE);
                } else {
                    //Nothhing was found
                    createDialogEmptyResults(context, selected, mapboxMap.getLocationComponent().getLastKnownLocation().getLatitude(), mapboxMap.getLocationComponent().getLastKnownLocation().getLongitude(), distance, randonautDialogsListener, mapboxMap);
                }

                //saveData();
                progressdialog.dismiss();
            }

            @Override
            public void onFailure(Call<GoAttractors> call, Throwable t) {
                progressdialog.dismiss();
                createDialogEmptyResults(context, selected, mapboxMap.getLocationComponent().getLastKnownLocation().getLatitude(), mapboxMap.getLocationComponent().getLastKnownLocation().getLongitude(), distance, randonautDialogsListener, mapboxMap);

            }


        });
    }

    public void getPsuedo(final View view, final MapboxMap mapboxMap, final Context context,
                          final int distance, final String selected, final RandonautAttractorListener randonautDialogsListener) {

        //Empty previous run
        locationList = new ArrayList<>();
        mapboxMap.clear();
       // removeRecyclerView(view);

        //Start ProgressDialog
        progressdialog = new ProgressDialog(context);
        progressdialog.setMessage("Looking for " + selected + "s " + "please wait....");
        progressdialog.show();
        progressdialog.setCancelable(false);
        progressdialog.setCanceledOnTouchOutside(false);

        OkHttpClient okHttpClient = new OkHttpClient().newBuilder()
                .connectTimeout(175, TimeUnit.SECONDS)
                .readTimeout(175, TimeUnit.SECONDS)
                .writeTimeout(175, TimeUnit.SECONDS)
                .build();

        Retrofit retrofit = new Retrofit.Builder()
                .baseUrl(new String(Base64.decode(MyRandonautFragment.getBaseApi(),Base64.DEFAULT)))
                .client(okHttpClient)
                .addConverterFactory(GsonConverterFactory.create())
                .build();

        randoWrapperApi = retrofit.create(RandoWrapperApi.class);

        Call<Sizes> callGetSizes = randoWrapperApi.getSizes(distance);

        callGetSizes.enqueue(new Callback<Sizes>() {
            @Override
            public void onResponse(Call<Sizes> call, Response<Sizes> response) {

                N = response.body().getN();

                int seed = 0;
                if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.LOLLIPOP) {
                    seed = ThreadLocalRandom.current().nextInt(0, 2147483647);
                } else {
                    seed = 23;
                }

                Call<List<PseudoAttractor>> callGetPsuedo = randoWrapperApi.getPsuedo(N,
                        mapboxMap.getLocationComponent().getLastKnownLocation().getLatitude(), mapboxMap.getLocationComponent().getLastKnownLocation().getLongitude(), distance, seed, 4);

                callGetPsuedo.enqueue(new Callback<List<PseudoAttractor>>() {
                    @Override
                    public void onResponse(Call<List<PseudoAttractor>> call, Response<List<PseudoAttractor>> response) {
                        int i = 0;
                        int count = 0;
                        int amount = 0;

                        for (PseudoAttractor psuedos : response.body()) {
                            count++;
                        }

                        PseudoAttractorLocation attractorLocations[] = new PseudoAttractorLocation[count];


                        for (PseudoAttractor psuedos : response.body()) {

                            //First Part
                            String GID = psuedos.getGID();
                            String TID = psuedos.getTID();
                            String LID = psuedos.getLID();
                            double type = psuedos.getType();
                            double x_ = psuedos.getX();
                            double y_ = psuedos.getY();

                            //Second part
                            double x = psuedos.getLatitude(); //Used in map
                            double y = psuedos.getLongitude(); //Used in map

                            double distance = psuedos.getDistance();
                            double initialBearing = psuedos.getInitialBearing();
                            double finalBearing = psuedos.getFinalBearing();

                            //Third part
                            double side = psuedos.getSide();
                            double distanceErr = psuedos.getDistanceErr();
                            double radiusM = psuedos.getRadiusM();
                            double n = psuedos.getN();
                            double mean = psuedos.getMean();
                            double rarity = psuedos.getRarity();
                            double power_old = psuedos.getPower_old();
                            double power = psuedos.getPower();
                            double z_score = psuedos.getZ_score();
                            double probability_single = psuedos.getProbability_single();
                            double integral_score = psuedos.getIntegral_score();
                            double significance = psuedos.getSignificance();
                            double probability = psuedos.getProbability();
                            double FILTERING_SIGNIFICANCE = psuedos.getFILTERING_SIGNIFICANCE();

                            //##TODO: FIX THE GID/TID/UID FOR PSEUDO AND ATTRACTORS
                            attractorLocations[i]=new PseudoAttractorLocation(new LatLng(x, y), 3333,  3333,  3333,  x_,  y_,  distance,  initialBearing,  finalBearing, side,  distanceErr,  radiusM, n,  mean, rarity,  power_old,  probability_single,  integral_score,  significance,  probability, FILTERING_SIGNIFICANCE, type, radiusM,  power,  z_score);

                            if(type == 1) {
                                mDatabaseHelper = new DatabaseHelper(context, attractorTable);
                                mapboxMap.addMarker(new MarkerOptions()
                                        .position(new LatLng(x, y))
                                        .title("Attractor"));

                                //Generate Circle
                                mapboxMap.addPolygon(generatePerimeter(
                                        new LatLng(x, y),
                                        (radiusM/1000),
                                        64));

                                amount++;
                                MyRandonautFragment.psuedo++;
                                SingleRecyclerViewLocation singleLocation = new SingleRecyclerViewLocation();
                                singleLocation.setType((attractorLocations[i].getType()));
                                singleLocation.setRadiusm((attractorLocations[i].getRadiusm()));
                                singleLocation.setPower((attractorLocations[i].getPower()));
                                singleLocation.setZ_score((attractorLocations[i].getZ_score()));
                                singleLocation.setLocationCoordinates(attractorLocations[i].getCoordinate());
                                singleLocation.setPsuedo(true);

                                locationList.add(singleLocation);

                                AddData(voidTable,
                                        attractorLocations[i].getCoordinate().getLatitude(),
                                        attractorLocations[i].getCoordinate().getLongitude(),
                                        attractorLocations[i].getGID(),
                                        attractorLocations[i].getTID(),
                                        attractorLocations[i].getLID(),

                                        attractorLocations[i].getX(),
                                        attractorLocations[i].getY(),
                                        attractorLocations[i].getDistance(),
                                        attractorLocations[i].getInitialBearing(),
                                        attractorLocations[i].getFinalBearing(),
                                        attractorLocations[i].getSide(),
                                        attractorLocations[i].getDistanceErr(),
                                        attractorLocations[i].getRadiusM(),
                                        attractorLocations[i].getN(),
                                        attractorLocations[i].getMean(),
                                        attractorLocations[i].getRarity(),
                                        attractorLocations[i].getPower_old(),
                                        attractorLocations[i].getProbability_single(),
                                        attractorLocations[i].getdoubleegral_score(),
                                        attractorLocations[i].getSignificance(),
                                        attractorLocations[i].getProbability(),
                                        attractorLocations[i].getFILTERING_SIGNIFICANCE(),
                                        attractorLocations[i].getType(),
                                        attractorLocations[i].getRadiusM(),
                                        attractorLocations[i].getPower(),
                                        attractorLocations[i].getZ_score(),
                                        1, 0);
                            }

                            if(type == 2) {
                                mDatabaseHelper = new DatabaseHelper(context, voidTable);
                                mapboxMap.addMarker(new MarkerOptions()
                                        .position(new LatLng(x, y))
                                        .title("Void"));

                                //Generate Circle
                                mapboxMap.addPolygon(generatePerimeter(
                                        new LatLng(x, y),
                                        (attractorLocations[i].getRadiusM()/1000),
                                        64));

                                amount++;
                                MyRandonautFragment.psuedo++;
                                SingleRecyclerViewLocation singleLocation = new SingleRecyclerViewLocation();
                                singleLocation.setType((attractorLocations[i].getType()));
                                singleLocation.setRadiusm((attractorLocations[i].getRadiusm()));
                                singleLocation.setPower((attractorLocations[i].getPower()));
                                singleLocation.setZ_score((attractorLocations[i].getZ_score()));
                                singleLocation.setLocationCoordinates(attractorLocations[i].getCoordinate());
                                singleLocation.setPsuedo(true);

                                locationList.add(singleLocation);

                                AddData(voidTable,
                                        attractorLocations[i].getCoordinate().getLatitude(),
                                        attractorLocations[i].getCoordinate().getLongitude(),
                                        attractorLocations[i].getGID(),
                                        attractorLocations[i].getTID(),
                                        attractorLocations[i].getLID(),

                                        attractorLocations[i].getX(),
                                        attractorLocations[i].getY(),
                                        attractorLocations[i].getDistance(),
                                        attractorLocations[i].getInitialBearing(),
                                        attractorLocations[i].getFinalBearing(),
                                        attractorLocations[i].getSide(),
                                        attractorLocations[i].getDistanceErr(),
                                        attractorLocations[i].getRadiusM(),
                                        attractorLocations[i].getN(),
                                        attractorLocations[i].getMean(),
                                        attractorLocations[i].getRarity(),
                                        attractorLocations[i].getPower_old(),
                                        attractorLocations[i].getProbability_single(),
                                        attractorLocations[i].getdoubleegral_score(),
                                        attractorLocations[i].getSignificance(),
                                        attractorLocations[i].getProbability(),
                                        attractorLocations[i].getFILTERING_SIGNIFICANCE(),
                                        attractorLocations[i].getType(),
                                        attractorLocations[i].getRadiusM(),
                                        attractorLocations[i].getPower(),
                                        attractorLocations[i].getZ_score(),
                                        1, 0);

                            }


                            i++;

                        }

                        if(amount > 0){
                            //initRecyclerView(context, view, mapboxMap);
                            randonautDialogsListener.onData(locationList);
                            MyRandonautFragment.startButton.setVisibility(View.GONE);
                            //   navigateButton.setVisibility(View.VISIBLE);
                            MyRandonautFragment.resetButton.setVisibility(View.VISIBLE);
                        } else {

                            createDialogEmptyResults(context, selected, mapboxMap.getLocationComponent().getLastKnownLocation().getLatitude(), mapboxMap.getLocationComponent().getLastKnownLocation().getLongitude(), distance, randonautDialogsListener, mapboxMap);
                        }
                     //   saveData(); -> REMOVE later



                        progressdialog.dismiss();


                    }

                    @Override
                    public void onFailure(Call<List<PseudoAttractor>> call, Throwable t) {
                        createDialogEmptyResults(context, selected, mapboxMap.getLocationComponent().getLastKnownLocation().getLatitude(), mapboxMap.getLocationComponent().getLastKnownLocation().getLongitude(), distance, randonautDialogsListener, mapboxMap);
                        progressdialog.dismiss();
                    }
                });


            }

            @Override
            public void onFailure(Call<Sizes> call, Throwable t) {

            }

        });
    }

    public void createDialogEmptyResults(Context context, String selected, final double lat, final double lon, final int radius, final RandonautAttractorListener randonautDialogsListener, final MapboxMap mapboxMap) {

        new AlertDialog.Builder(context)
                .setTitle("No " + selected + "s found")
                .setMessage("No anomalies currently detected in the area, supplying a pseudo-point for you instead.")

                // Specifying a listener allows you to take an action before dismissing the dialog.
                // The dialog is automatically dismissed when a dialog button is clicked.
                .setPositiveButton("OK", new DialogInterface.OnClickListener() {
                    public void onClick(DialogInterface dialog, int which) {
                        // Continue with delete operation
                        // getQuantumRandom(lat, lon, radius);

                        double[] testresutlt = getQuantumRandom(lat, lon, radius);
                        mapboxMap.addMarker(new MarkerOptions()
                                .position(new LatLng(testresutlt[0], testresutlt[1]))
                                .title("Pseudo Point"));

//                        //Generate Circle
//                        mapboxMap.addPolygon(generatePerimeter(
//                                new LatLng(testresutlt[0], testresutlt[1]),
//                                (attractorLocations[i].getRadiusM()/1000),
//                                64));


                        SingleRecyclerViewLocation singleLocation = new SingleRecyclerViewLocation();

                        singleLocation.setType(0);
                        singleLocation.setLocationCoordinates(new LatLng(testresutlt[0], testresutlt[1]));

                        locationList.add(singleLocation);
                        randonautDialogsListener.onData(locationList);
                        MyRandonautFragment.startButton.setVisibility(View.GONE);
                        //   navigateButton.setVisibility(View.VISIBLE);
                        MyRandonautFragment.resetButton.setVisibility(View.VISIBLE);
                        dialog.dismiss();

                    }
                })
                .setIcon(android.R.drawable.ic_dialog_alert)
                .show();
    }

    

    public static double[] getQuantumRandom(double lat, double lon, int radius){
        double[] result = new double[2];

        Boolean dnn = false;
        while (dnn == false)
        {
            double lat01 = lat + radius * cos(180 * Math.PI / 180) / (6371000 * Math.PI / 180);
            double dlat = ((lat + radius / (6371000 * Math.PI / 180)) - lat01) * 1000000;
            double lon01 = lon + radius * sin(270 * Math.PI / 180) / cos(lat * Math.PI / 180) / (6371000 * Math.PI / 180);
            double dlon = ((lon + radius * sin(90 * Math.PI / 180) / cos(lat * Math.PI / 180) / (6371000 * Math.PI / 180)) - lon01) * 1000000;
            double lat1 = lat;
            double lon1 = lon;
            double rlat;
            double rlon;
            rlat = ThreadLocalRandom.current().nextInt(0, (int)dlat);
            rlon = ThreadLocalRandom.current().nextInt(0, (int)dlon);
            lat1 = lat01 + (rlat / 1000000);
            lon1 = lon01 + (rlon / 1000000);
            int dif = GetDistance(lat, lon, lat1, lon1);
            if (dif > radius) { }
            else
            {
                result[0] = lat1;
                result[1] = lon1;
                dnn = true;
            }
        }
        return result;
    }

    public static int GetDistance(double lat0, double lon0, double lat1, double lon1){
        double dlon = (lon1 - lon0) * Math.PI / 180;
        double dlat = (lat1 - lat0) * Math.PI / 180;

        double a = (sin(dlat / 2) * sin(dlat / 2)) + cos(lat0 * Math.PI / 180) * cos(lat1 * Math.PI / 180) * (sin(dlon / 2) * sin(dlon / 2));
        double angle = 2 * atan2(sqrt(a), sqrt(1 - a));
        return (int) (angle * 6371000);
    }
    
    /**
     * Draw circle on the mapview
     */
    public PolygonOptions generatePerimeter(LatLng centerCoordinates, double radiusInKilometers, int numberOfSides) {
        List<LatLng> positions = new ArrayList<>();
        double distanceX = radiusInKilometers / (111.319 * cos(centerCoordinates.getLatitude() * Math.PI / 180));
        double distanceY = radiusInKilometers / 110.574;

        double slice = (2 * Math.PI) / numberOfSides;

        double theta;
        double x;
        double y;
        LatLng position;
        for (int i = 0; i < numberOfSides; ++i) {
            theta = i * slice;
            x = distanceX * cos(theta);
            y = distanceY * sin(theta);

            position = new LatLng(centerCoordinates.getLatitude() + y,
                    centerCoordinates.getLongitude() + x);
            positions.add(position);
        }
        return new PolygonOptions()
                .addAll(positions)
                .fillColor(Color.BLUE)
                .alpha(0.4f);
    }

    //Write to Database
    //#TODO: FIX THE GID/TID/LID
    public void AddData (String table, double x, double y, double GID, double TID, double LID, double x_, double y_, double distance, double initialBearing, double finalBearing, Double side, double distanceErr, double radiusM, Double n, double mean, Double rarity, double power_old, double probability_single, double integral_score, double significance, double probability, double FILTERING_SIGNIFICANCE, double type, double radiusm, double power, double z_score, double pseudo, int report) {
        boolean insertData = mDatabaseHelper.addData(table, x,  y,  GID,  TID,  LID,  x_,  y_,  distance,  initialBearing,  finalBearing,  side,  distanceErr,  radiusM,  n,  mean,  rarity,  power_old,  probability_single,  integral_score,  significance,  probability,  FILTERING_SIGNIFICANCE,  type,  radiusm,  power,  z_score, pseudo,  report);

        if (insertData){

        } else {

        }
    }


}